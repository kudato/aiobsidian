{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"aiobsidian","text":"<p>Async Python client for the Obsidian Local REST API plugin.</p> <p>aiobsidian provides a clean, fully-typed async interface to interact with your Obsidian vault programmatically \u2014 read and write notes, search content, execute commands, and more.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Async/await \u2014 built on httpx for high-performance async HTTP</li> <li>Fully typed \u2014 complete type annotations and a <code>py.typed</code> marker</li> <li>Resource-based API \u2014 intuitive access through <code>client.vault</code>, <code>client.search</code>, etc.</li> <li>Pydantic v2 models \u2014 structured, validated response objects</li> <li>Multiple content formats \u2014 Markdown, JSON, and document maps</li> <li>Flexible search \u2014 simple text, Dataview DQL, and JsonLogic queries</li> </ul>"},{"location":"#quick-example","title":"Quick example","text":"<pre><code>import asyncio\nfrom aiobsidian import ObsidianClient\n\nasync def main():\n    async with ObsidianClient(api_key=\"your-api-key\") as client:\n        # Check server status\n        status = await client.system.status()\n        print(f\"Obsidian v{status.versions.obsidian}\")\n\n        # Read a note\n        content = await client.vault.get(\"Notes/hello.md\")\n        print(content)\n\n        # Search the vault\n        results = await client.search.simple(\"python\")\n        for result in results:\n            print(result.filename)\n\nasyncio.run(main())\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Installation \u2014 install aiobsidian and set up the Obsidian plugin</li> <li>Quick Start \u2014 get up and running in minutes</li> <li>User Guide \u2014 learn all the operations available</li> <li>API Reference \u2014 full API documentation</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":""},{"location":"getting-started/configuration/#constructor-parameters","title":"Constructor parameters","text":"Parameter Type Default Description <code>api_key</code> <code>str</code> required API key from the Local REST API plugin settings <code>host</code> <code>str</code> <code>\"127.0.0.1\"</code> Hostname of the REST API server <code>port</code> <code>int</code> <code>27124</code> Port number <code>scheme</code> <code>str</code> <code>\"https\"</code> URL scheme (<code>\"https\"</code> or <code>\"http\"</code>) <code>timeout</code> <code>float</code> <code>30.0</code> Request timeout in seconds <code>verify_ssl</code> <code>bool</code> <code>False</code> Whether to verify SSL certificates <code>http_client</code> <code>httpx.AsyncClient \\| None</code> <code>None</code> Optional pre-configured HTTP client"},{"location":"getting-started/configuration/#basic-usage","title":"Basic usage","text":"<pre><code>from aiobsidian import ObsidianClient\n\nclient = ObsidianClient(api_key=\"your-api-key\")\n</code></pre>"},{"location":"getting-started/configuration/#custom-host-and-port","title":"Custom host and port","text":"<p>If the REST API plugin is configured to use a different host or port:</p> <pre><code>client = ObsidianClient(\n    api_key=\"your-api-key\",\n    host=\"192.168.1.100\",\n    port=8080,\n)\n</code></pre>"},{"location":"getting-started/configuration/#using-http-instead-of-https","title":"Using HTTP instead of HTTPS","text":"<pre><code>client = ObsidianClient(\n    api_key=\"your-api-key\",\n    scheme=\"http\",\n)\n</code></pre>"},{"location":"getting-started/configuration/#custom-httpx-client","title":"Custom httpx client","text":"<p>You can provide your own <code>httpx.AsyncClient</code> for advanced use cases like custom middleware, proxies, or connection pooling:</p> <pre><code>import httpx\nfrom aiobsidian import ObsidianClient\n\ncustom_http = httpx.AsyncClient(\n    base_url=\"https://127.0.0.1:27124\",\n    headers={\"Authorization\": \"Bearer your-api-key\"},\n    timeout=60.0,\n    verify=False,\n    limits=httpx.Limits(max_connections=10),\n)\n\nclient = ObsidianClient(\n    api_key=\"your-api-key\",\n    http_client=custom_http,\n)\n</code></pre> <p>Note</p> <p>When you provide an external <code>httpx.AsyncClient</code>, aiobsidian will not close it when <code>aclose()</code> is called. You are responsible for managing its lifecycle.</p>"},{"location":"getting-started/configuration/#lifecycle-management","title":"Lifecycle management","text":""},{"location":"getting-started/configuration/#context-manager-recommended","title":"Context manager (recommended)","text":"<pre><code>async with ObsidianClient(api_key=\"your-api-key\") as client:\n    status = await client.system.status()\n# Client is automatically closed here\n</code></pre>"},{"location":"getting-started/configuration/#manual-close","title":"Manual close","text":"<pre><code>client = ObsidianClient(api_key=\"your-api-key\")\ntry:\n    status = await client.system.status()\nfinally:\n    await client.aclose()\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ol> <li>Obsidian \u2014 download from obsidian.md</li> <li>Local REST API plugin \u2014 install from the Obsidian Community Plugins:<ul> <li>Open Obsidian Settings \u2192 Community Plugins \u2192 Browse</li> <li>Search for \"Local REST API\"</li> <li>Install and enable the plugin</li> <li>Copy the API key from the plugin settings</li> </ul> </li> </ol>"},{"location":"getting-started/installation/#install-aiobsidian","title":"Install aiobsidian","text":"pipuvPoetry <pre><code>pip install aiobsidian\n</code></pre> <pre><code>uv add aiobsidian\n</code></pre> <pre><code>poetry add aiobsidian\n</code></pre>"},{"location":"getting-started/installation/#ssl-certificates","title":"SSL certificates","text":"<p>The Local REST API plugin uses self-signed HTTPS certificates by default. aiobsidian disables SSL verification (<code>verify_ssl=False</code>) to handle this automatically.</p> <p>Warning</p> <p>If you need strict SSL verification (e.g. behind a reverse proxy with real certificates), pass <code>verify_ssl=True</code> when creating the client:</p> <pre><code>client = ObsidianClient(api_key=\"...\", verify_ssl=True)\n</code></pre>"},{"location":"getting-started/installation/#verify-the-installation","title":"Verify the installation","text":"<pre><code>import asyncio\nfrom aiobsidian import ObsidianClient\n\nasync def main():\n    async with ObsidianClient(api_key=\"your-api-key\") as client:\n        status = await client.system.status()\n        print(f\"Connected! Obsidian v{status.versions.obsidian}\")\n\nasyncio.run(main())\n</code></pre> <p>If you see the Obsidian version printed, you're all set!</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide walks you through the most common operations with aiobsidian.</p>"},{"location":"getting-started/quickstart/#creating-a-client","title":"Creating a client","text":"<p>Use <code>ObsidianClient</code> as an async context manager to ensure the HTTP connection is properly closed:</p> <pre><code>import asyncio\nfrom aiobsidian import ObsidianClient\n\nasync def main():\n    async with ObsidianClient(api_key=\"your-api-key\") as client:\n        status = await client.system.status()\n        print(status.authenticated)  # True\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#available-resources","title":"Available resources","text":"<p>The client provides access to several resource groups:</p> Resource Access Description vault <code>client.vault</code> Read, create, update, and delete vault files active <code>client.active</code> Operate on the currently open file periodic <code>client.periodic</code> Access daily, weekly, monthly, quarterly, yearly notes commands <code>client.commands</code> List and execute Obsidian commands search <code>client.search</code> Search vault content open <code>client.open</code> Open files in the Obsidian UI system <code>client.system</code> Server status and OpenAPI spec"},{"location":"getting-started/quickstart/#reading-a-note","title":"Reading a note","text":"<pre><code># Get raw Markdown\ncontent = await client.vault.get(\"Notes/hello.md\")\nprint(content)\n\n# Get structured JSON (with frontmatter, tags, stats)\nfrom aiobsidian import ContentType\n\nnote = await client.vault.get(\"Notes/hello.md\", content_type=ContentType.NOTE_JSON)\nprint(note.frontmatter)\nprint(note.tags)\n</code></pre>"},{"location":"getting-started/quickstart/#creating-a-note","title":"Creating a note","text":"<pre><code>await client.vault.update(\"Notes/new-note.md\", \"# My New Note\\n\\nHello, world!\")\n</code></pre>"},{"location":"getting-started/quickstart/#searching","title":"Searching","text":"<pre><code>results = await client.search.simple(\"python asyncio\")\nfor result in results:\n    print(f\"{result.filename} (score: {result.score})\")\n    for match in result.matches or []:\n        print(f\"  ...{match.context}...\")\n</code></pre>"},{"location":"getting-started/quickstart/#executing-commands","title":"Executing commands","text":"<pre><code>commands = await client.commands.list()\nfor cmd in commands[:5]:\n    print(f\"{cmd.id}: {cmd.name}\")\n\n# Execute a specific command\nawait client.commands.execute(\"editor:toggle-bold\")\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next steps","text":"<ul> <li>Configuration \u2014 customize connection settings</li> <li>Vault Operations \u2014 full guide on vault file operations</li> <li>Error Handling \u2014 handle API errors gracefully</li> </ul>"},{"location":"guide/active-file/","title":"Active File","text":"<p>The <code>client.active</code> resource operates on the file currently open (focused) in the Obsidian editor.</p>"},{"location":"guide/active-file/#reading-the-active-file","title":"Reading the active file","text":""},{"location":"guide/active-file/#markdown-content","title":"Markdown content","text":"<pre><code>content = await client.active.get()\nprint(content)\n</code></pre>"},{"location":"guide/active-file/#structured-json","title":"Structured JSON","text":"<pre><code>from aiobsidian import ContentType\n\nnote = await client.active.get(content_type=ContentType.NOTE_JSON)\nprint(note.frontmatter)\nprint(note.tags)\nprint(note.path)\n</code></pre>"},{"location":"guide/active-file/#document-map","title":"Document map","text":"<pre><code>from aiobsidian import ContentType\n\ndoc_map = await client.active.get(content_type=ContentType.DOCUMENT_MAP)\nprint(doc_map.headings)\nprint(doc_map.blocks)\n</code></pre>"},{"location":"guide/active-file/#replacing-content","title":"Replacing content","text":"<p>Replace the entire content of the active file:</p> <pre><code>await client.active.update(\"# Updated Title\\n\\nNew content here.\")\n</code></pre>"},{"location":"guide/active-file/#appending-content","title":"Appending content","text":"<pre><code>await client.active.append(\"\\n\\n---\\n\\nAppended at the end.\")\n</code></pre>"},{"location":"guide/active-file/#patching-sections","title":"Patching sections","text":"<p>Works the same as vault patching:</p> <pre><code>from aiobsidian import PatchOperation, TargetType\n\nawait client.active.patch(\n    \"Content to add under heading\",\n    operation=PatchOperation.APPEND,\n    target_type=TargetType.HEADING,\n    target=\"My Section\",\n)\n</code></pre>"},{"location":"guide/active-file/#deleting-the-active-file","title":"Deleting the active file","text":"<pre><code>await client.active.delete()\n</code></pre> <p>Warning</p> <p>This permanently deletes the currently active file from the vault.</p>"},{"location":"guide/commands/","title":"Commands","text":"<p>The <code>client.commands</code> resource lets you list and execute Obsidian commands programmatically.</p>"},{"location":"guide/commands/#listing-commands","title":"Listing commands","text":"<pre><code>commands = await client.commands.list()\nfor cmd in commands:\n    print(f\"{cmd.id}: {cmd.name}\")\n</code></pre> <p>Example output:</p> <pre><code>editor:toggle-bold: Toggle bold\neditor:toggle-italic: Toggle italic\napp:open-settings: Open settings\nfile-explorer:reveal-active-file: Reveal active file in navigation\n</code></pre>"},{"location":"guide/commands/#executing-a-command","title":"Executing a command","text":"<pre><code>await client.commands.execute(\"editor:toggle-bold\")\n</code></pre>"},{"location":"guide/commands/#finding-a-command-by-name","title":"Finding a command by name","text":"<pre><code>commands = await client.commands.list()\ncmd = next((c for c in commands if \"bold\" in c.name.lower()), None)\nif cmd:\n    await client.commands.execute(cmd.id)\n</code></pre> <p>Tip</p> <p>Command IDs are stable across Obsidian sessions, so you can hard-code them in your scripts once you know the ID.</p>"},{"location":"guide/error-handling/","title":"Error Handling","text":"<p>aiobsidian uses a simple exception hierarchy for API errors.</p>"},{"location":"guide/error-handling/#exception-hierarchy","title":"Exception hierarchy","text":"<pre><code>ObsidianError          # Base exception for all aiobsidian errors\n\u2514\u2500\u2500 APIError           # HTTP error from the REST API\n    \u251c\u2500\u2500 AuthenticationError  # 401 Unauthorized\n    \u2514\u2500\u2500 NotFoundError        # 404 Not Found\n</code></pre>"},{"location":"guide/error-handling/#catching-errors","title":"Catching errors","text":"<pre><code>from aiobsidian import (\n    ObsidianClient,\n    APIError,\n    AuthenticationError,\n    NotFoundError,\n)\n\nasync with ObsidianClient(api_key=\"your-api-key\") as client:\n    try:\n        content = await client.vault.get(\"nonexistent.md\")\n    except NotFoundError:\n        print(\"File not found\")\n    except AuthenticationError:\n        print(\"Invalid API key\")\n    except APIError as e:\n        print(f\"API error [{e.status_code}]: {e.message}\")\n</code></pre>"},{"location":"guide/error-handling/#apierror-attributes","title":"APIError attributes","text":"<p>All API exceptions (<code>APIError</code>, <code>AuthenticationError</code>, <code>NotFoundError</code>) have these attributes:</p> Attribute Type Description <code>status_code</code> <code>int</code> HTTP status code (e.g. 401, 404, 500) <code>message</code> <code>str</code> Error message from the API response <code>error_code</code> <code>int \\| None</code> Optional numeric error code from the API"},{"location":"guide/error-handling/#example-retry-on-transient-errors","title":"Example: retry on transient errors","text":"<pre><code>from aiobsidian import APIError\n\nasync def get_with_retry(client, path, retries=3):\n    for attempt in range(retries):\n        try:\n            return await client.vault.get(path)\n        except APIError as e:\n            if e.status_code &gt;= 500 and attempt &lt; retries - 1:\n                continue\n            raise\n</code></pre>"},{"location":"guide/open/","title":"Open Files","text":"<p>The <code>client.open</code> resource opens files in the Obsidian UI.</p>"},{"location":"guide/open/#opening-a-file","title":"Opening a file","text":"<pre><code>await client.open.open(\"Notes/hello.md\")\n</code></pre> <p>This will focus the file in the Obsidian editor.</p>"},{"location":"guide/open/#opening-in-a-new-tab","title":"Opening in a new tab","text":"<pre><code>await client.open.open(\"Notes/hello.md\", new_leaf=True)\n</code></pre> <p>Setting <code>new_leaf=True</code> opens the file in a new tab (leaf) instead of replacing the current one.</p>"},{"location":"guide/periodic-notes/","title":"Periodic Notes","text":"<p>The <code>client.periodic</code> resource manages periodic notes \u2014 daily, weekly, monthly, quarterly, and yearly.</p> <p>Note</p> <p>Periodic notes require the corresponding Obsidian plugin to be configured (e.g. Daily Notes core plugin or the Periodic Notes community plugin).</p>"},{"location":"guide/periodic-notes/#available-periods","title":"Available periods","text":"<pre><code>from aiobsidian import Period\n\nPeriod.DAILY      # Daily note\nPeriod.WEEKLY     # Weekly note\nPeriod.MONTHLY    # Monthly note\nPeriod.QUARTERLY  # Quarterly note\nPeriod.YEARLY     # Yearly note\n</code></pre>"},{"location":"guide/periodic-notes/#reading-a-periodic-note","title":"Reading a periodic note","text":"<pre><code>from aiobsidian import Period\n\n# Get today's daily note as Markdown\ncontent = await client.periodic.get(Period.DAILY)\nprint(content)\n\n# Get this week's note as structured JSON\nfrom aiobsidian import ContentType\n\nnote = await client.periodic.get(\n    Period.WEEKLY,\n    content_type=ContentType.NOTE_JSON,\n)\nprint(note.frontmatter)\n</code></pre>"},{"location":"guide/periodic-notes/#creating-or-updating-a-periodic-note","title":"Creating or updating a periodic note","text":"<p>Replace the entire content of a periodic note. If the note doesn't exist yet, it will be created:</p> <pre><code>await client.periodic.update(\n    Period.DAILY,\n    \"# Daily Note\\n\\n- [ ] Task 1\\n- [ ] Task 2\",\n)\n</code></pre>"},{"location":"guide/periodic-notes/#appending-to-a-periodic-note","title":"Appending to a periodic note","text":"<pre><code>await client.periodic.append(\n    Period.DAILY,\n    \"\\n\\n## Evening Review\\n\\nToday was productive.\",\n)\n</code></pre>"},{"location":"guide/periodic-notes/#patching-a-periodic-note","title":"Patching a periodic note","text":"<p>Target specific sections within a periodic note:</p> <pre><code>from aiobsidian import PatchOperation, Period, TargetType\n\nawait client.periodic.patch(\n    Period.DAILY,\n    \"- [x] Completed task\",\n    operation=PatchOperation.APPEND,\n    target_type=TargetType.HEADING,\n    target=\"Tasks\",\n)\n</code></pre>"},{"location":"guide/periodic-notes/#deleting-a-periodic-note","title":"Deleting a periodic note","text":"<pre><code>await client.periodic.delete(Period.DAILY)\n</code></pre>"},{"location":"guide/search/","title":"Search","text":"<p>The <code>client.search</code> resource provides three search methods: simple text search, Dataview DQL queries, and JsonLogic queries.</p>"},{"location":"guide/search/#simple-text-search","title":"Simple text search","text":"<p>Search for text across all files in the vault:</p> <pre><code>results = await client.search.simple(\"python asyncio\")\nfor result in results:\n    print(f\"{result.filename} (score: {result.score})\")\n    for match in result.matches or []:\n        print(f\"  ...{match.context}...\")\n</code></pre>"},{"location":"guide/search/#context-length","title":"Context length","text":"<p>Control how much surrounding text is included with each match:</p> <pre><code>results = await client.search.simple(\"python\", context_length=200)\n</code></pre>"},{"location":"guide/search/#dataview-dql-search","title":"Dataview DQL search","text":"<p>Use Dataview Query Language for structured queries:</p> <pre><code>results = await client.search.dataview('TABLE file.name FROM \"Notes\"')\nfor result in results:\n    print(result.filename)\n    print(result.result)  # Raw Dataview result data\n</code></pre> <p>Note</p> <p>Dataview DQL search requires the Dataview plugin to be installed and enabled in Obsidian.</p>"},{"location":"guide/search/#jsonlogic-search","title":"JsonLogic search","text":"<p>Use JsonLogic for programmatic query construction:</p> <pre><code>results = await client.search.jsonlogic({\"glob\": [\"*.md\"]})\nfor result in results:\n    print(result.filename)\n</code></pre>"},{"location":"guide/search/#search-result-structure","title":"Search result structure","text":"<p>Each search method returns a list of <code>SearchResult</code> objects:</p> Field Type Description <code>filename</code> <code>str</code> Path to the matching file <code>score</code> <code>float \\| None</code> Relevance score (simple search only) <code>matches</code> <code>list[SearchMatch] \\| None</code> Match locations with context (simple search only) <code>result</code> <code>Any</code> Raw result data (Dataview/JsonLogic only) <p>Each <code>SearchMatch</code> contains:</p> Field Type Description <code>match</code> <code>dict[str, int]</code> Match start/end positions <code>context</code> <code>str</code> Surrounding text context"},{"location":"guide/vault/","title":"Vault Operations","text":"<p>The <code>client.vault</code> resource provides full CRUD operations on files and directories in your Obsidian vault.</p>"},{"location":"guide/vault/#reading-files","title":"Reading files","text":""},{"location":"guide/vault/#markdown-content","title":"Markdown content","text":"<pre><code>content = await client.vault.get(\"Notes/hello.md\")\nprint(content)  # Raw Markdown string\n</code></pre>"},{"location":"guide/vault/#structured-json","title":"Structured JSON","text":"<p>Get the note with parsed frontmatter, tags, and file stats:</p> <pre><code>from aiobsidian import ContentType\n\nnote = await client.vault.get(\"Notes/hello.md\", content_type=ContentType.NOTE_JSON)\nprint(note.content)      # Markdown body\nprint(note.frontmatter)  # {\"title\": \"Hello\", \"tags\": [\"greeting\"]}\nprint(note.tags)          # [\"greeting\"]\nprint(note.path)          # \"Notes/hello.md\"\nprint(note.stat.mtime)   # Last modification timestamp\n</code></pre>"},{"location":"guide/vault/#document-map","title":"Document map","text":"<p>Discover the structure of a note \u2014 headings, blocks, and frontmatter fields:</p> <pre><code>from aiobsidian import ContentType\n\ndoc_map = await client.vault.get(\"Notes/hello.md\", content_type=ContentType.DOCUMENT_MAP)\nprint(doc_map.headings)           # [\"Introduction\", \"Details\"]\nprint(doc_map.blocks)             # [\"block-id-1\", \"block-id-2\"]\nprint(doc_map.frontmatter_fields) # [\"title\", \"tags\"]\n</code></pre> <p>This is useful for finding valid targets before using <code>patch()</code>.</p>"},{"location":"guide/vault/#creating-files","title":"Creating files","text":"<pre><code>await client.vault.update(\n    \"Notes/new-note.md\",\n    \"# My New Note\\n\\nThis is the content.\",\n)\n</code></pre> <p>Note</p> <p>If the file already exists, it will be overwritten.</p>"},{"location":"guide/vault/#appending-content","title":"Appending content","text":"<pre><code>await client.vault.append(\"Notes/hello.md\", \"\\n\\n## New Section\\n\\nAppended text.\")\n</code></pre>"},{"location":"guide/vault/#patching-specific-sections","title":"Patching specific sections","text":"<p>The <code>patch()</code> method lets you modify a specific part of a note:</p>"},{"location":"guide/vault/#patch-a-heading","title":"Patch a heading","text":"<pre><code>from aiobsidian import PatchOperation, TargetType\n\nawait client.vault.patch(\n    \"Notes/hello.md\",\n    \"New content under this heading\",\n    operation=PatchOperation.APPEND,\n    target_type=TargetType.HEADING,\n    target=\"Introduction\",\n)\n</code></pre>"},{"location":"guide/vault/#patch-a-block-reference","title":"Patch a block reference","text":"<pre><code>await client.vault.patch(\n    \"Notes/hello.md\",\n    \"Replaced block content\",\n    operation=PatchOperation.REPLACE,\n    target_type=TargetType.BLOCK,\n    target=\"block-id-1\",\n)\n</code></pre>"},{"location":"guide/vault/#patch-frontmatter","title":"Patch frontmatter","text":"<pre><code>import json\n\nawait client.vault.patch(\n    \"Notes/hello.md\",\n    json.dumps({\"status\": \"published\"}),\n    operation=PatchOperation.REPLACE,\n    target_type=TargetType.FRONTMATTER,\n    target=\"status\",\n)\n</code></pre>"},{"location":"guide/vault/#patch-operations","title":"Patch operations","text":"Operation Description <code>PatchOperation.APPEND</code> Insert content after the target <code>PatchOperation.PREPEND</code> Insert content before the target <code>PatchOperation.REPLACE</code> Replace the target content entirely"},{"location":"guide/vault/#target-types","title":"Target types","text":"Target type Description <code>TargetType.HEADING</code> A heading section (e.g. <code>## My Heading</code>) <code>TargetType.BLOCK</code> A block reference (e.g. <code>^block-id</code>) <code>TargetType.FRONTMATTER</code> A YAML frontmatter field"},{"location":"guide/vault/#deleting-files","title":"Deleting files","text":"<pre><code>await client.vault.delete(\"Notes/old-note.md\")\n</code></pre>"},{"location":"guide/vault/#listing-files","title":"Listing files","text":"<pre><code># List all files in the vault root\ndirectory = await client.vault.list()\nfor path in directory.files:\n    print(path)\n\n# List files in a subdirectory\nnotes = await client.vault.list(\"Notes\")\nfor path in notes.files:\n    print(path)\n</code></pre>"},{"location":"reference/client/","title":"Client","text":""},{"location":"reference/client/#aiobsidian.ObsidianClient","title":"<code>ObsidianClient(api_key, *, host=DEFAULT_HOST, port=DEFAULT_PORT, scheme=DEFAULT_SCHEME, timeout=DEFAULT_TIMEOUT, verify_ssl=False, http_client=None)</code>","text":"<p>Async client for the Obsidian Local REST API.</p> <p>Provides access to vault files, the active file, periodic notes, commands, search, and system information through resource properties.</p> <p>Can be used as an async context manager:</p> <pre><code>async with ObsidianClient(api_key=\"your-key\") as client:\n    status = await client.system.status()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>API key from the Local REST API plugin settings.</p> required <code>host</code> <code>str</code> <p>Hostname of the Obsidian REST API server.</p> <code>DEFAULT_HOST</code> <code>port</code> <code>int</code> <p>Port number of the Obsidian REST API server.</p> <code>DEFAULT_PORT</code> <code>scheme</code> <code>str</code> <p>URL scheme (<code>\"https\"</code> or <code>\"http\"</code>).</p> <code>DEFAULT_SCHEME</code> <code>timeout</code> <code>float</code> <p>Request timeout in seconds.</p> <code>DEFAULT_TIMEOUT</code> <code>verify_ssl</code> <code>bool</code> <p>Whether to verify SSL certificates. Defaults to <code>False</code> because the plugin uses self-signed certificates.</p> <code>False</code> <code>http_client</code> <code>AsyncClient | None</code> <p>Optional pre-configured <code>httpx.AsyncClient</code>. When provided, the client will not be closed on <code>aclose()</code>.</p> <code>None</code> Source code in <code>src/aiobsidian/_client.py</code> <pre><code>def __init__(\n    self,\n    api_key: str,\n    *,\n    host: str = DEFAULT_HOST,\n    port: int = DEFAULT_PORT,\n    scheme: str = DEFAULT_SCHEME,\n    timeout: float = DEFAULT_TIMEOUT,\n    verify_ssl: bool = False,\n    http_client: httpx.AsyncClient | None = None,\n) -&gt; None:\n    self._host = host\n    self._port = port\n    self._scheme = scheme\n    self._base_url = f\"{scheme}://{host}:{port}\"\n    self._api_key = api_key\n    self._timeout = timeout\n    self._verify_ssl = verify_ssl\n    self._external_client = http_client is not None\n    self._http = http_client or self._build_http_client()\n</code></pre>"},{"location":"reference/client/#aiobsidian.ObsidianClient.vault","title":"<code>vault</code>  <code>cached</code> <code>property</code>","text":"<p>Access vault file operations (read, create, append, patch, delete, list).</p>"},{"location":"reference/client/#aiobsidian.ObsidianClient.active","title":"<code>active</code>  <code>cached</code> <code>property</code>","text":"<p>Access the currently active file in Obsidian.</p>"},{"location":"reference/client/#aiobsidian.ObsidianClient.periodic","title":"<code>periodic</code>  <code>cached</code> <code>property</code>","text":"<p>Access periodic notes (daily, weekly, monthly, quarterly, yearly).</p>"},{"location":"reference/client/#aiobsidian.ObsidianClient.commands","title":"<code>commands</code>  <code>cached</code> <code>property</code>","text":"<p>List and execute Obsidian commands.</p>"},{"location":"reference/client/#aiobsidian.ObsidianClient.search","title":"<code>search</code>  <code>cached</code> <code>property</code>","text":"<p>Search vault content (simple text, Dataview DQL, JsonLogic).</p>"},{"location":"reference/client/#aiobsidian.ObsidianClient.open","title":"<code>open</code>  <code>cached</code> <code>property</code>","text":"<p>Open files in the Obsidian UI.</p>"},{"location":"reference/client/#aiobsidian.ObsidianClient.system","title":"<code>system</code>  <code>cached</code> <code>property</code>","text":"<p>Access server status and OpenAPI specification.</p>"},{"location":"reference/client/#aiobsidian.ObsidianClient.request","title":"<code>request(method, path, *, content=None, json=None, headers=None, params=None)</code>  <code>async</code>","text":"<p>Send an HTTP request to the Obsidian REST API.</p> <p>This is a low-level method used internally by resource classes. Prefer using the resource methods (e.g. <code>client.vault.get()</code>) for typical operations.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>HTTP method (GET, POST, PUT, PATCH, DELETE).</p> required <code>path</code> <code>str</code> <p>API endpoint path (e.g. <code>\"/vault/note.md\"</code>).</p> required <code>content</code> <code>str | bytes | None</code> <p>Raw request body.</p> <code>None</code> <code>json</code> <code>Any</code> <p>JSON-serializable request body.</p> <code>None</code> <code>headers</code> <code>dict[str, Any] | None</code> <p>Additional HTTP headers.</p> <code>None</code> <code>params</code> <code>dict[str, Any] | None</code> <p>URL query parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>The <code>httpx.Response</code> object.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If the API key is invalid (HTTP 401).</p> <code>NotFoundError</code> <p>If the resource is not found (HTTP 404).</p> <code>APIError</code> <p>For any other HTTP error (status &gt;= 400).</p> Source code in <code>src/aiobsidian/_client.py</code> <pre><code>async def request(\n    self,\n    method: str,\n    path: str,\n    *,\n    content: str | bytes | None = None,\n    json: Any = None,\n    headers: dict[str, Any] | None = None,\n    params: dict[str, Any] | None = None,\n) -&gt; httpx.Response:\n    \"\"\"Send an HTTP request to the Obsidian REST API.\n\n    This is a low-level method used internally by resource classes.\n    Prefer using the resource methods (e.g. `client.vault.get()`)\n    for typical operations.\n\n    Args:\n        method: HTTP method (GET, POST, PUT, PATCH, DELETE).\n        path: API endpoint path (e.g. `\"/vault/note.md\"`).\n        content: Raw request body.\n        json: JSON-serializable request body.\n        headers: Additional HTTP headers.\n        params: URL query parameters.\n\n    Returns:\n        The `httpx.Response` object.\n\n    Raises:\n        AuthenticationError: If the API key is invalid (HTTP 401).\n        NotFoundError: If the resource is not found (HTTP 404).\n        APIError: For any other HTTP error (status &gt;= 400).\n    \"\"\"\n    response = await self._http.request(\n        method,\n        path,\n        content=content,\n        json=json,\n        headers=headers,\n        params=params,\n    )\n    if response.status_code &gt;= 400:\n        self._raise_for_status(response)\n    return response\n</code></pre>"},{"location":"reference/client/#aiobsidian.ObsidianClient.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Close the underlying HTTP client.</p> <p>If an external <code>httpx.AsyncClient</code> was provided to the constructor, this method is a no-op \u2014 the caller is responsible for closing it.</p> Source code in <code>src/aiobsidian/_client.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Close the underlying HTTP client.\n\n    If an external `httpx.AsyncClient` was provided to the\n    constructor, this method is a no-op \u2014 the caller is\n    responsible for closing it.\n    \"\"\"\n    if not self._external_client:\n        await self._http.aclose()\n</code></pre>"},{"location":"reference/enums/","title":"Enums","text":""},{"location":"reference/enums/#aiobsidian.Period","title":"<code>Period</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Time period for periodic notes.</p> <p>Used with <code>client.periodic</code> to access daily, weekly, monthly, quarterly, or yearly notes.</p>"},{"location":"reference/enums/#aiobsidian.Period.DAILY","title":"<code>DAILY = 'daily'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Daily note.</p>"},{"location":"reference/enums/#aiobsidian.Period.WEEKLY","title":"<code>WEEKLY = 'weekly'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Weekly note.</p>"},{"location":"reference/enums/#aiobsidian.Period.MONTHLY","title":"<code>MONTHLY = 'monthly'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Monthly note.</p>"},{"location":"reference/enums/#aiobsidian.Period.QUARTERLY","title":"<code>QUARTERLY = 'quarterly'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Quarterly note.</p>"},{"location":"reference/enums/#aiobsidian.Period.YEARLY","title":"<code>YEARLY = 'yearly'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Yearly note.</p>"},{"location":"reference/enums/#aiobsidian.PatchOperation","title":"<code>PatchOperation</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Operation type for PATCH requests.</p> <p>Determines how content is inserted relative to the target.</p>"},{"location":"reference/enums/#aiobsidian.PatchOperation.APPEND","title":"<code>APPEND = 'append'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Insert content after the target.</p>"},{"location":"reference/enums/#aiobsidian.PatchOperation.PREPEND","title":"<code>PREPEND = 'prepend'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Insert content before the target.</p>"},{"location":"reference/enums/#aiobsidian.PatchOperation.REPLACE","title":"<code>REPLACE = 'replace'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Replace the target content entirely.</p>"},{"location":"reference/enums/#aiobsidian.TargetType","title":"<code>TargetType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Target type for PATCH requests.</p> <p>Specifies which part of a note the patch operation targets.</p>"},{"location":"reference/enums/#aiobsidian.TargetType.HEADING","title":"<code>HEADING = 'heading'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target a heading section (e.g. <code>## My Heading</code>).</p>"},{"location":"reference/enums/#aiobsidian.TargetType.BLOCK","title":"<code>BLOCK = 'block'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target a block reference (e.g. <code>^block-id</code>).</p>"},{"location":"reference/enums/#aiobsidian.TargetType.FRONTMATTER","title":"<code>FRONTMATTER = 'frontmatter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target a frontmatter field.</p>"},{"location":"reference/enums/#aiobsidian.ContentType","title":"<code>ContentType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Content types (MIME types) used by the Obsidian REST API.</p> <p>Controls the format of request and response bodies.</p>"},{"location":"reference/enums/#aiobsidian.ContentType.MARKDOWN","title":"<code>MARKDOWN = 'text/markdown'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Plain Markdown text.</p>"},{"location":"reference/enums/#aiobsidian.ContentType.NOTE_JSON","title":"<code>NOTE_JSON = 'application/vnd.olrapi.note+json'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Structured JSON with content, frontmatter, tags, and stats.</p>"},{"location":"reference/enums/#aiobsidian.ContentType.DOCUMENT_MAP","title":"<code>DOCUMENT_MAP = 'application/vnd.olrapi.document-map+json'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>JSON listing headings, blocks, and frontmatter fields.</p>"},{"location":"reference/enums/#aiobsidian.ContentType.DATAVIEW_DQL","title":"<code>DATAVIEW_DQL = 'application/vnd.olrapi.dataview.dql+txt'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dataview Query Language query string.</p>"},{"location":"reference/enums/#aiobsidian.ContentType.JSONLOGIC","title":"<code>JSONLOGIC = 'application/vnd.olrapi.jsonlogic+json'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>JsonLogic query object.</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#aiobsidian.ObsidianError","title":"<code>ObsidianError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all aiobsidian errors.</p>"},{"location":"reference/exceptions/#aiobsidian.APIError","title":"<code>APIError(status_code, message, error_code=None)</code>","text":"<p>               Bases: <code>ObsidianError</code></p> <p>Error returned by the Obsidian REST API.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <p>HTTP status code of the response.</p> <code>message</code> <p>Error message from the API.</p> <code>error_code</code> <p>Optional numeric error code from the API.</p> Source code in <code>src/aiobsidian/_exceptions.py</code> <pre><code>def __init__(\n    self,\n    status_code: int,\n    message: str,\n    error_code: int | None = None,\n) -&gt; None:\n    self.status_code = status_code\n    self.message = message\n    self.error_code = error_code\n    msg = f\"[{status_code}] {message}\"\n    if error_code is not None:\n        msg += f\" (error_code={error_code})\"\n    super().__init__(msg)\n</code></pre>"},{"location":"reference/exceptions/#aiobsidian.AuthenticationError","title":"<code>AuthenticationError(status_code, message, error_code=None)</code>","text":"<p>               Bases: <code>APIError</code></p> <p>HTTP 401 Unauthorized \u2014 invalid or missing API key.</p> Source code in <code>src/aiobsidian/_exceptions.py</code> <pre><code>def __init__(\n    self,\n    status_code: int,\n    message: str,\n    error_code: int | None = None,\n) -&gt; None:\n    self.status_code = status_code\n    self.message = message\n    self.error_code = error_code\n    msg = f\"[{status_code}] {message}\"\n    if error_code is not None:\n        msg += f\" (error_code={error_code})\"\n    super().__init__(msg)\n</code></pre>"},{"location":"reference/exceptions/#aiobsidian.NotFoundError","title":"<code>NotFoundError(status_code, message, error_code=None)</code>","text":"<p>               Bases: <code>APIError</code></p> <p>HTTP 404 Not Found \u2014 the requested resource does not exist.</p> Source code in <code>src/aiobsidian/_exceptions.py</code> <pre><code>def __init__(\n    self,\n    status_code: int,\n    message: str,\n    error_code: int | None = None,\n) -&gt; None:\n    self.status_code = status_code\n    self.message = message\n    self.error_code = error_code\n    msg = f\"[{status_code}] {message}\"\n    if error_code is not None:\n        msg += f\" (error_code={error_code})\"\n    super().__init__(msg)\n</code></pre>"},{"location":"reference/models/","title":"Models","text":""},{"location":"reference/models/#vault-models","title":"Vault Models","text":""},{"location":"reference/models/#aiobsidian.models.vault.FileStat","title":"<code>FileStat</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>File system metadata for a vault file.</p> <p>Attributes:</p> Name Type Description <code>ctime</code> <code>int</code> <p>Creation time as a Unix timestamp in milliseconds.</p> <code>mtime</code> <code>int</code> <p>Last modification time as a Unix timestamp in milliseconds.</p> <code>size</code> <code>int</code> <p>File size in bytes.</p>"},{"location":"reference/models/#aiobsidian.models.vault.NoteJson","title":"<code>NoteJson</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Structured JSON representation of a note.</p> <p>Returned when requesting a file with <code>ContentType.NOTE_JSON</code>.</p> <p>Attributes:</p> Name Type Description <code>content</code> <code>str</code> <p>The raw Markdown content of the note.</p> <code>frontmatter</code> <code>dict[str, Any]</code> <p>Parsed YAML frontmatter as a dictionary.</p> <code>tags</code> <code>list[str]</code> <p>List of tags found in the note.</p> <code>path</code> <code>str</code> <p>Path to the file relative to the vault root.</p> <code>stat</code> <code>FileStat</code> <p>File system metadata.</p>"},{"location":"reference/models/#aiobsidian.models.vault.DocumentMap","title":"<code>DocumentMap</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Map of a note's structure (headings, blocks, frontmatter fields).</p> <p>Returned when requesting a file with <code>ContentType.DOCUMENT_MAP</code>. Useful for discovering valid patch targets.</p> <p>Attributes:</p> Name Type Description <code>headings</code> <code>list[str]</code> <p>List of heading texts in the document.</p> <code>blocks</code> <code>list[str]</code> <p>List of block reference IDs.</p> <code>frontmatter_fields</code> <code>list[str]</code> <p>List of frontmatter field names.</p>"},{"location":"reference/models/#aiobsidian.models.vault.VaultDirectory","title":"<code>VaultDirectory</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Directory listing of files in the vault.</p> <p>Attributes:</p> Name Type Description <code>files</code> <code>list[str]</code> <p>List of file paths relative to the vault root.</p>"},{"location":"reference/models/#search-models","title":"Search Models","text":""},{"location":"reference/models/#aiobsidian.models.search.SearchMatch","title":"<code>SearchMatch</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A single match within a search result.</p> <p>Attributes:</p> Name Type Description <code>match</code> <code>MatchSpan</code> <p>Span with start and end positions of the match.</p> <code>context</code> <code>str</code> <p>Surrounding text context for the match.</p>"},{"location":"reference/models/#aiobsidian.models.search.SearchResult","title":"<code>SearchResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A search result entry.</p> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str</code> <p>Path to the matching file relative to the vault root.</p> <code>score</code> <code>float | None</code> <p>Relevance score (present for simple search).</p> <code>matches</code> <code>list[SearchMatch] | None</code> <p>List of match locations with context (present for simple search).</p> <code>result</code> <code>dict[str, Any] | list[Any] | None</code> <p>Raw result data (present for Dataview/JsonLogic queries).</p>"},{"location":"reference/models/#system-models","title":"System Models","text":""},{"location":"reference/models/#aiobsidian.models.system.Versions","title":"<code>Versions</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Version information for Obsidian and the REST API plugin.</p> <p>Attributes:</p> Name Type Description <code>obsidian</code> <code>str</code> <p>Obsidian application version string.</p> <code>self_</code> <code>str</code> <p>REST API plugin version string (aliased from <code>\"self\"</code>).</p>"},{"location":"reference/models/#aiobsidian.models.system.ServerStatus","title":"<code>ServerStatus</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Status response from the Obsidian REST API root endpoint.</p> <p>Attributes:</p> Name Type Description <code>status</code> <code>str</code> <p>Status message (typically <code>\"OK\"</code>).</p> <code>service</code> <code>str</code> <p>Service identifier string.</p> <code>authenticated</code> <code>bool</code> <p>Whether the request was authenticated.</p> <code>versions</code> <code>Versions</code> <p>Version information for Obsidian and the plugin.</p>"},{"location":"reference/models/#command-models","title":"Command Models","text":""},{"location":"reference/models/#aiobsidian.models.commands.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An Obsidian command.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique command identifier (e.g. <code>\"editor:toggle-bold\"</code>).</p> <code>name</code> <code>str</code> <p>Human-readable command name (e.g. <code>\"Toggle bold\"</code>).</p>"},{"location":"reference/resources/active/","title":"Active File Resource","text":""},{"location":"reference/resources/active/#aiobsidian.resources.active.ActiveFileResource","title":"<code>ActiveFileResource(client)</code>","text":"<p>               Bases: <code>ContentResource</code></p> <p>Operations on the currently active (open) file in Obsidian.</p> Source code in <code>src/aiobsidian/_base_resource.py</code> <pre><code>def __init__(self, client: ObsidianClient) -&gt; None:\n    self._client = client\n</code></pre>"},{"location":"reference/resources/active/#aiobsidian.resources.active.ActiveFileResource.get","title":"<code>get(*, content_type=ContentType.MARKDOWN)</code>  <code>async</code>","text":"<pre><code>get(\n    *, content_type: Literal[ContentType.MARKDOWN] = ...\n) -&gt; str\n</code></pre><pre><code>get(\n    *, content_type: Literal[ContentType.NOTE_JSON]\n) -&gt; NoteJson\n</code></pre><pre><code>get(\n    *, content_type: Literal[ContentType.DOCUMENT_MAP]\n) -&gt; DocumentMap\n</code></pre> <p>Get the content of the active file.</p> <p>Parameters:</p> Name Type Description Default <code>content_type</code> <code>ContentType</code> <p>Desired response format. Use <code>ContentType.MARKDOWN</code> for raw text, <code>ContentType.NOTE_JSON</code> for structured JSON, or <code>ContentType.DOCUMENT_MAP</code> for headings/blocks.</p> <code>MARKDOWN</code> <p>Returns:</p> Type Description <code>str | NoteJson | DocumentMap</code> <p>File content as <code>str</code>, <code>NoteJson</code>, or <code>DocumentMap</code></p> <code>str | NoteJson | DocumentMap</code> <p>depending on the requested content type.</p> Source code in <code>src/aiobsidian/resources/active.py</code> <pre><code>async def get(\n    self,\n    *,\n    content_type: ContentType = ContentType.MARKDOWN,\n) -&gt; str | NoteJson | DocumentMap:\n    \"\"\"Get the content of the active file.\n\n    Args:\n        content_type: Desired response format. Use\n            `ContentType.MARKDOWN` for raw text,\n            `ContentType.NOTE_JSON` for structured JSON, or\n            `ContentType.DOCUMENT_MAP` for headings/blocks.\n\n    Returns:\n        File content as `str`, `NoteJson`, or `DocumentMap`\n        depending on the requested content type.\n    \"\"\"\n    return await self._get_content(self._BASE_URL, content_type)\n</code></pre>"},{"location":"reference/resources/active/#aiobsidian.resources.active.ActiveFileResource.update","title":"<code>update(content)</code>  <code>async</code>","text":"<p>Replace the entire content of the active file.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>New Markdown content for the file.</p> required Source code in <code>src/aiobsidian/resources/active.py</code> <pre><code>async def update(self, content: str) -&gt; None:\n    \"\"\"Replace the entire content of the active file.\n\n    Args:\n        content: New Markdown content for the file.\n    \"\"\"\n    await self._client.request(\n        \"PUT\",\n        self._BASE_URL,\n        content=content,\n        headers={\"Content-Type\": ContentType.MARKDOWN},\n    )\n</code></pre>"},{"location":"reference/resources/active/#aiobsidian.resources.active.ActiveFileResource.append","title":"<code>append(content)</code>  <code>async</code>","text":"<p>Append content to the end of the active file.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Markdown content to append.</p> required Source code in <code>src/aiobsidian/resources/active.py</code> <pre><code>async def append(self, content: str) -&gt; None:\n    \"\"\"Append content to the end of the active file.\n\n    Args:\n        content: Markdown content to append.\n    \"\"\"\n    await self._append_content(self._BASE_URL, content)\n</code></pre>"},{"location":"reference/resources/active/#aiobsidian.resources.active.ActiveFileResource.patch","title":"<code>patch(content, *, operation, target_type, target, target_delimiter='::')</code>  <code>async</code>","text":"<p>Patch a specific section of the active file.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Content to insert or replace.</p> required <code>operation</code> <code>PatchOperation</code> <p>How to apply the content (<code>append</code>, <code>prepend</code>, or <code>replace</code>).</p> required <code>target_type</code> <code>TargetType</code> <p>What to target (<code>heading</code>, <code>block</code>, or <code>frontmatter</code>).</p> required <code>target</code> <code>str</code> <p>The target identifier.</p> required <code>target_delimiter</code> <code>str</code> <p>Delimiter for nested targets.</p> <code>'::'</code> Source code in <code>src/aiobsidian/resources/active.py</code> <pre><code>async def patch(\n    self,\n    content: str,\n    *,\n    operation: PatchOperation,\n    target_type: TargetType,\n    target: str,\n    target_delimiter: str = \"::\",\n) -&gt; None:\n    \"\"\"Patch a specific section of the active file.\n\n    Args:\n        content: Content to insert or replace.\n        operation: How to apply the content (`append`, `prepend`,\n            or `replace`).\n        target_type: What to target (`heading`, `block`, or\n            `frontmatter`).\n        target: The target identifier.\n        target_delimiter: Delimiter for nested targets.\n    \"\"\"\n    await self._patch_content(\n        self._BASE_URL,\n        content,\n        operation=operation,\n        target_type=target_type,\n        target=target,\n        target_delimiter=target_delimiter,\n    )\n</code></pre>"},{"location":"reference/resources/active/#aiobsidian.resources.active.ActiveFileResource.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Delete the currently active file.</p> Source code in <code>src/aiobsidian/resources/active.py</code> <pre><code>async def delete(self) -&gt; None:\n    \"\"\"Delete the currently active file.\"\"\"\n    await self._client.request(\"DELETE\", self._BASE_URL)\n</code></pre>"},{"location":"reference/resources/commands/","title":"Commands Resource","text":""},{"location":"reference/resources/commands/#aiobsidian.resources.commands.CommandsResource","title":"<code>CommandsResource(client)</code>","text":"<p>               Bases: <code>BaseResource</code></p> <p>List and execute Obsidian commands.</p> Source code in <code>src/aiobsidian/_base_resource.py</code> <pre><code>def __init__(self, client: ObsidianClient) -&gt; None:\n    self._client = client\n</code></pre>"},{"location":"reference/resources/commands/#aiobsidian.resources.commands.CommandsResource.list","title":"<code>list()</code>  <code>async</code>","text":"<p>List all available Obsidian commands.</p> <p>Returns:</p> Type Description <code>list[Command]</code> <p>A list of <code>Command</code> objects with <code>id</code> and <code>name</code> fields.</p> Source code in <code>src/aiobsidian/resources/commands.py</code> <pre><code>async def list(self) -&gt; list[Command]:\n    \"\"\"List all available Obsidian commands.\n\n    Returns:\n        A list of `Command` objects with `id` and `name` fields.\n    \"\"\"\n    response = await self._client.request(\"GET\", f\"{self._BASE_URL}/\")\n    data = response.json()\n    return [Command.model_validate(c) for c in data[\"commands\"]]\n</code></pre>"},{"location":"reference/resources/commands/#aiobsidian.resources.commands.CommandsResource.execute","title":"<code>execute(command_id)</code>  <code>async</code>","text":"<p>Execute an Obsidian command by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>command_id</code> <code>str</code> <p>The unique identifier of the command (e.g. <code>\"editor:toggle-bold\"</code>).</p> required Source code in <code>src/aiobsidian/resources/commands.py</code> <pre><code>async def execute(self, command_id: str) -&gt; None:\n    \"\"\"Execute an Obsidian command by its ID.\n\n    Args:\n        command_id: The unique identifier of the command\n            (e.g. `\"editor:toggle-bold\"`).\n    \"\"\"\n    await self._client.request(\"POST\", f\"{self._BASE_URL}/{command_id}/\")\n</code></pre>"},{"location":"reference/resources/open/","title":"Open Resource","text":""},{"location":"reference/resources/open/#aiobsidian.resources.open.OpenResource","title":"<code>OpenResource(client)</code>","text":"<p>               Bases: <code>BaseResource</code></p> <p>Open files in the Obsidian UI.</p> Source code in <code>src/aiobsidian/_base_resource.py</code> <pre><code>def __init__(self, client: ObsidianClient) -&gt; None:\n    self._client = client\n</code></pre>"},{"location":"reference/resources/open/#aiobsidian.resources.open.OpenResource.open","title":"<code>open(filename, *, new_leaf=False)</code>  <code>async</code>","text":"<p>Open a file in Obsidian.</p> <pre><code>await client.open.open(\"Notes/hello.md\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the file to open, relative to the vault root.</p> required <code>new_leaf</code> <code>bool</code> <p>If <code>True</code>, open the file in a new tab/pane.</p> <code>False</code> Source code in <code>src/aiobsidian/resources/open.py</code> <pre><code>async def open(\n    self,\n    filename: str,\n    *,\n    new_leaf: bool = False,\n) -&gt; None:\n    \"\"\"Open a file in Obsidian.\n\n    ```python\n    await client.open.open(\"Notes/hello.md\")\n    ```\n\n    Args:\n        filename: Path to the file to open, relative to the vault root.\n        new_leaf: If `True`, open the file in a new tab/pane.\n    \"\"\"\n    params: dict[str, str] = {}\n    if new_leaf:\n        params[\"newLeaf\"] = \"true\"\n    await self._client.request(\n        \"POST\",\n        f\"{self._BASE_URL}/{filename}\",\n        params=params,\n    )\n</code></pre>"},{"location":"reference/resources/periodic/","title":"Periodic Notes Resource","text":""},{"location":"reference/resources/periodic/#aiobsidian.resources.periodic.PeriodicNotesResource","title":"<code>PeriodicNotesResource(client)</code>","text":"<p>               Bases: <code>ContentResource</code></p> <p>Operations on periodic notes (daily, weekly, monthly, quarterly, yearly).</p> Source code in <code>src/aiobsidian/_base_resource.py</code> <pre><code>def __init__(self, client: ObsidianClient) -&gt; None:\n    self._client = client\n</code></pre>"},{"location":"reference/resources/periodic/#aiobsidian.resources.periodic.PeriodicNotesResource.get","title":"<code>get(period, *, content_type=ContentType.MARKDOWN)</code>  <code>async</code>","text":"<pre><code>get(\n    period: Period,\n    *,\n    content_type: Literal[ContentType.MARKDOWN] = ...,\n) -&gt; str\n</code></pre><pre><code>get(\n    period: Period,\n    *,\n    content_type: Literal[ContentType.NOTE_JSON],\n) -&gt; NoteJson\n</code></pre><pre><code>get(\n    period: Period,\n    *,\n    content_type: Literal[ContentType.DOCUMENT_MAP],\n) -&gt; DocumentMap\n</code></pre> <p>Get the content of a periodic note.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>Period</code> <p>The time period (e.g. <code>Period.DAILY</code>).</p> required <code>content_type</code> <code>ContentType</code> <p>Desired response format.</p> <code>MARKDOWN</code> <p>Returns:</p> Type Description <code>str | NoteJson | DocumentMap</code> <p>Note content as <code>str</code>, <code>NoteJson</code>, or <code>DocumentMap</code></p> <code>str | NoteJson | DocumentMap</code> <p>depending on the requested content type.</p> Source code in <code>src/aiobsidian/resources/periodic.py</code> <pre><code>async def get(\n    self,\n    period: Period,\n    *,\n    content_type: ContentType = ContentType.MARKDOWN,\n) -&gt; str | NoteJson | DocumentMap:\n    \"\"\"Get the content of a periodic note.\n\n    Args:\n        period: The time period (e.g. `Period.DAILY`).\n        content_type: Desired response format.\n\n    Returns:\n        Note content as `str`, `NoteJson`, or `DocumentMap`\n        depending on the requested content type.\n    \"\"\"\n    return await self._get_content(f\"{self._BASE_URL}/{period}/\", content_type)\n</code></pre>"},{"location":"reference/resources/periodic/#aiobsidian.resources.periodic.PeriodicNotesResource.update","title":"<code>update(period, content)</code>  <code>async</code>","text":"<p>Replace the entire content of a periodic note.</p> <p>If the note does not exist, it will be created.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>Period</code> <p>The time period.</p> required <code>content</code> <code>str</code> <p>New Markdown content for the note.</p> required Source code in <code>src/aiobsidian/resources/periodic.py</code> <pre><code>async def update(self, period: Period, content: str) -&gt; None:\n    \"\"\"Replace the entire content of a periodic note.\n\n    If the note does not exist, it will be created.\n\n    Args:\n        period: The time period.\n        content: New Markdown content for the note.\n    \"\"\"\n    await self._client.request(\n        \"PUT\",\n        f\"{self._BASE_URL}/{period}/\",\n        content=content,\n        headers={\"Content-Type\": ContentType.MARKDOWN},\n    )\n</code></pre>"},{"location":"reference/resources/periodic/#aiobsidian.resources.periodic.PeriodicNotesResource.append","title":"<code>append(period, content)</code>  <code>async</code>","text":"<p>Append content to the end of a periodic note.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>Period</code> <p>The time period.</p> required <code>content</code> <code>str</code> <p>Markdown content to append.</p> required Source code in <code>src/aiobsidian/resources/periodic.py</code> <pre><code>async def append(self, period: Period, content: str) -&gt; None:\n    \"\"\"Append content to the end of a periodic note.\n\n    Args:\n        period: The time period.\n        content: Markdown content to append.\n    \"\"\"\n    await self._append_content(f\"{self._BASE_URL}/{period}/\", content)\n</code></pre>"},{"location":"reference/resources/periodic/#aiobsidian.resources.periodic.PeriodicNotesResource.patch","title":"<code>patch(period, content, *, operation, target_type, target, target_delimiter='::')</code>  <code>async</code>","text":"<p>Patch a specific section of a periodic note.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>Period</code> <p>The time period.</p> required <code>content</code> <code>str</code> <p>Content to insert or replace.</p> required <code>operation</code> <code>PatchOperation</code> <p>How to apply the content (<code>append</code>, <code>prepend</code>, or <code>replace</code>).</p> required <code>target_type</code> <code>TargetType</code> <p>What to target (<code>heading</code>, <code>block</code>, or <code>frontmatter</code>).</p> required <code>target</code> <code>str</code> <p>The target identifier.</p> required <code>target_delimiter</code> <code>str</code> <p>Delimiter for nested targets.</p> <code>'::'</code> Source code in <code>src/aiobsidian/resources/periodic.py</code> <pre><code>async def patch(\n    self,\n    period: Period,\n    content: str,\n    *,\n    operation: PatchOperation,\n    target_type: TargetType,\n    target: str,\n    target_delimiter: str = \"::\",\n) -&gt; None:\n    \"\"\"Patch a specific section of a periodic note.\n\n    Args:\n        period: The time period.\n        content: Content to insert or replace.\n        operation: How to apply the content (`append`, `prepend`,\n            or `replace`).\n        target_type: What to target (`heading`, `block`, or\n            `frontmatter`).\n        target: The target identifier.\n        target_delimiter: Delimiter for nested targets.\n    \"\"\"\n    await self._patch_content(\n        f\"{self._BASE_URL}/{period}/\",\n        content,\n        operation=operation,\n        target_type=target_type,\n        target=target,\n        target_delimiter=target_delimiter,\n    )\n</code></pre>"},{"location":"reference/resources/periodic/#aiobsidian.resources.periodic.PeriodicNotesResource.delete","title":"<code>delete(period)</code>  <code>async</code>","text":"<p>Delete a periodic note.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>Period</code> <p>The time period of the note to delete.</p> required Source code in <code>src/aiobsidian/resources/periodic.py</code> <pre><code>async def delete(self, period: Period) -&gt; None:\n    \"\"\"Delete a periodic note.\n\n    Args:\n        period: The time period of the note to delete.\n    \"\"\"\n    await self._client.request(\"DELETE\", f\"{self._BASE_URL}/{period}/\")\n</code></pre>"},{"location":"reference/resources/search/","title":"Search Resource","text":""},{"location":"reference/resources/search/#aiobsidian.resources.search.SearchResource","title":"<code>SearchResource(client)</code>","text":"<p>               Bases: <code>BaseResource</code></p> <p>Search vault content using different query methods.</p> Source code in <code>src/aiobsidian/_base_resource.py</code> <pre><code>def __init__(self, client: ObsidianClient) -&gt; None:\n    self._client = client\n</code></pre>"},{"location":"reference/resources/search/#aiobsidian.resources.search.SearchResource.simple","title":"<code>simple(query, *, context_length=100)</code>  <code>async</code>","text":"<p>Perform a simple text search across the vault.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query string.</p> required <code>context_length</code> <code>int</code> <p>Number of context characters to include around each match.</p> <code>100</code> <p>Returns:</p> Type Description <code>list[SearchResult]</code> <p>A list of <code>SearchResult</code> objects with matching files</p> <code>list[SearchResult]</code> <p>and context snippets.</p> Source code in <code>src/aiobsidian/resources/search.py</code> <pre><code>async def simple(\n    self,\n    query: str,\n    *,\n    context_length: int = 100,\n) -&gt; list[SearchResult]:\n    \"\"\"Perform a simple text search across the vault.\n\n    Args:\n        query: The search query string.\n        context_length: Number of context characters to include\n            around each match.\n\n    Returns:\n        A list of `SearchResult` objects with matching files\n        and context snippets.\n    \"\"\"\n    response = await self._client.request(\n        \"POST\",\n        f\"{self._BASE_URL}/simple/\",\n        params={\"query\": query, \"contextLength\": context_length},\n    )\n    return [SearchResult.model_validate(r) for r in response.json()]\n</code></pre>"},{"location":"reference/resources/search/#aiobsidian.resources.search.SearchResource.dataview","title":"<code>dataview(dql)</code>  <code>async</code>","text":"<p>Search using a Dataview Query Language (DQL) expression.</p> <p>Requires the Dataview plugin to be installed in Obsidian.</p> <p>Parameters:</p> Name Type Description Default <code>dql</code> <code>str</code> <p>A DQL query string (e.g. <code>\"TABLE file.name FROM #tag\"</code>).</p> required <p>Returns:</p> Type Description <code>list[SearchResult]</code> <p>A list of <code>SearchResult</code> objects.</p> Source code in <code>src/aiobsidian/resources/search.py</code> <pre><code>async def dataview(self, dql: str) -&gt; list[SearchResult]:\n    \"\"\"Search using a Dataview Query Language (DQL) expression.\n\n    Requires the Dataview plugin to be installed in Obsidian.\n\n    Args:\n        dql: A DQL query string (e.g. `\"TABLE file.name FROM #tag\"`).\n\n    Returns:\n        A list of `SearchResult` objects.\n    \"\"\"\n    response = await self._client.request(\n        \"POST\",\n        f\"{self._BASE_URL}/\",\n        content=dql,\n        headers={\"Content-Type\": ContentType.DATAVIEW_DQL},\n    )\n    return [SearchResult.model_validate(r) for r in response.json()]\n</code></pre>"},{"location":"reference/resources/search/#aiobsidian.resources.search.SearchResource.jsonlogic","title":"<code>jsonlogic(query)</code>  <code>async</code>","text":"<p>Search using a JsonLogic query object.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>dict[str, Any]</code> <p>A JsonLogic query dictionary (e.g. <code>{\"glob\": [\"*.md\"]}</code>).</p> required <p>Returns:</p> Type Description <code>list[SearchResult]</code> <p>A list of <code>SearchResult</code> objects.</p> Source code in <code>src/aiobsidian/resources/search.py</code> <pre><code>async def jsonlogic(self, query: dict[str, Any]) -&gt; list[SearchResult]:\n    \"\"\"Search using a JsonLogic query object.\n\n    Args:\n        query: A JsonLogic query dictionary\n            (e.g. `{\"glob\": [\"*.md\"]}`).\n\n    Returns:\n        A list of `SearchResult` objects.\n    \"\"\"\n    response = await self._client.request(\n        \"POST\",\n        f\"{self._BASE_URL}/\",\n        json=query,\n        headers={\"Content-Type\": ContentType.JSONLOGIC},\n    )\n    return [SearchResult.model_validate(r) for r in response.json()]\n</code></pre>"},{"location":"reference/resources/system/","title":"System Resource","text":""},{"location":"reference/resources/system/#aiobsidian.resources.system.SystemResource","title":"<code>SystemResource(client)</code>","text":"<p>               Bases: <code>BaseResource</code></p> <p>Access server status and the OpenAPI specification.</p> Source code in <code>src/aiobsidian/_base_resource.py</code> <pre><code>def __init__(self, client: ObsidianClient) -&gt; None:\n    self._client = client\n</code></pre>"},{"location":"reference/resources/system/#aiobsidian.resources.system.SystemResource.status","title":"<code>status()</code>  <code>async</code>","text":"<p>Get the current server status.</p> <p>Returns:</p> Type Description <code>ServerStatus</code> <p>A <code>ServerStatus</code> object with authentication state and</p> <code>ServerStatus</code> <p>version information.</p> Source code in <code>src/aiobsidian/resources/system.py</code> <pre><code>async def status(self) -&gt; ServerStatus:\n    \"\"\"Get the current server status.\n\n    Returns:\n        A `ServerStatus` object with authentication state and\n        version information.\n    \"\"\"\n    response = await self._client.request(\"GET\", \"/\")\n    return ServerStatus.model_validate(response.json())\n</code></pre>"},{"location":"reference/resources/system/#aiobsidian.resources.system.SystemResource.openapi","title":"<code>openapi()</code>  <code>async</code>","text":"<p>Get the OpenAPI specification of the REST API.</p> <p>Returns:</p> Type Description <code>str</code> <p>The OpenAPI spec as a YAML string.</p> Source code in <code>src/aiobsidian/resources/system.py</code> <pre><code>async def openapi(self) -&gt; str:\n    \"\"\"Get the OpenAPI specification of the REST API.\n\n    Returns:\n        The OpenAPI spec as a YAML string.\n    \"\"\"\n    response = await self._client.request(\"GET\", \"/openapi.yaml\")\n    return response.text\n</code></pre>"},{"location":"reference/resources/vault/","title":"Vault Resource","text":""},{"location":"reference/resources/vault/#aiobsidian.resources.vault.VaultResource","title":"<code>VaultResource(client)</code>","text":"<p>               Bases: <code>ContentResource</code></p> <p>Operations on files and directories in the vault.</p> Source code in <code>src/aiobsidian/_base_resource.py</code> <pre><code>def __init__(self, client: ObsidianClient) -&gt; None:\n    self._client = client\n</code></pre>"},{"location":"reference/resources/vault/#aiobsidian.resources.vault.VaultResource.get","title":"<code>get(path, *, content_type=ContentType.MARKDOWN)</code>  <code>async</code>","text":"<pre><code>get(\n    path: str,\n    *,\n    content_type: Literal[ContentType.MARKDOWN] = ...,\n) -&gt; str\n</code></pre><pre><code>get(\n    path: str,\n    *,\n    content_type: Literal[ContentType.NOTE_JSON],\n) -&gt; NoteJson\n</code></pre><pre><code>get(\n    path: str,\n    *,\n    content_type: Literal[ContentType.DOCUMENT_MAP],\n) -&gt; DocumentMap\n</code></pre> <p>Get the content of a vault file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the file relative to the vault root (e.g. <code>\"Notes/hello.md\"</code>).</p> required <code>content_type</code> <code>ContentType</code> <p>Desired response format. Use <code>ContentType.MARKDOWN</code> for raw text, <code>ContentType.NOTE_JSON</code> for structured JSON, or <code>ContentType.DOCUMENT_MAP</code> for headings/blocks.</p> <code>MARKDOWN</code> <p>Returns:</p> Type Description <code>str | NoteJson | DocumentMap</code> <p>File content as <code>str</code>, <code>NoteJson</code>, or <code>DocumentMap</code></p> <code>str | NoteJson | DocumentMap</code> <p>depending on the requested content type.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the file does not exist.</p> Source code in <code>src/aiobsidian/resources/vault.py</code> <pre><code>async def get(\n    self,\n    path: str,\n    *,\n    content_type: ContentType = ContentType.MARKDOWN,\n) -&gt; str | NoteJson | DocumentMap:\n    \"\"\"Get the content of a vault file.\n\n    Args:\n        path: Path to the file relative to the vault root\n            (e.g. `\"Notes/hello.md\"`).\n        content_type: Desired response format. Use\n            `ContentType.MARKDOWN` for raw text,\n            `ContentType.NOTE_JSON` for structured JSON, or\n            `ContentType.DOCUMENT_MAP` for headings/blocks.\n\n    Returns:\n        File content as `str`, `NoteJson`, or `DocumentMap`\n        depending on the requested content type.\n\n    Raises:\n        NotFoundError: If the file does not exist.\n    \"\"\"\n    return await self._get_content(f\"{self._BASE_URL}/{path}\", content_type)\n</code></pre>"},{"location":"reference/resources/vault/#aiobsidian.resources.vault.VaultResource.update","title":"<code>update(path, content)</code>  <code>async</code>","text":"<p>Create or replace a file in the vault.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path for the file relative to the vault root.</p> required <code>content</code> <code>str</code> <p>Markdown content to write.</p> required Source code in <code>src/aiobsidian/resources/vault.py</code> <pre><code>async def update(self, path: str, content: str) -&gt; None:\n    \"\"\"Create or replace a file in the vault.\n\n    Args:\n        path: Path for the file relative to the vault root.\n        content: Markdown content to write.\n    \"\"\"\n    await self._client.request(\n        \"PUT\",\n        f\"{self._BASE_URL}/{path}\",\n        content=content,\n        headers={\"Content-Type\": ContentType.MARKDOWN},\n    )\n</code></pre>"},{"location":"reference/resources/vault/#aiobsidian.resources.vault.VaultResource.append","title":"<code>append(path, content)</code>  <code>async</code>","text":"<p>Append content to the end of a vault file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the file relative to the vault root.</p> required <code>content</code> <code>str</code> <p>Markdown content to append.</p> required <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the file does not exist.</p> Source code in <code>src/aiobsidian/resources/vault.py</code> <pre><code>async def append(self, path: str, content: str) -&gt; None:\n    \"\"\"Append content to the end of a vault file.\n\n    Args:\n        path: Path to the file relative to the vault root.\n        content: Markdown content to append.\n\n    Raises:\n        NotFoundError: If the file does not exist.\n    \"\"\"\n    await self._append_content(f\"{self._BASE_URL}/{path}\", content)\n</code></pre>"},{"location":"reference/resources/vault/#aiobsidian.resources.vault.VaultResource.patch","title":"<code>patch(path, content, *, operation, target_type, target, target_delimiter='::')</code>  <code>async</code>","text":"<p>Patch a specific section of a vault file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the file relative to the vault root.</p> required <code>content</code> <code>str</code> <p>Content to insert or replace.</p> required <code>operation</code> <code>PatchOperation</code> <p>How to apply the content (<code>append</code>, <code>prepend</code>, or <code>replace</code>).</p> required <code>target_type</code> <code>TargetType</code> <p>What to target (<code>heading</code>, <code>block</code>, or <code>frontmatter</code>).</p> required <code>target</code> <code>str</code> <p>The target identifier (e.g. heading text, block ID, or frontmatter field name).</p> required <code>target_delimiter</code> <code>str</code> <p>Delimiter for nested targets.</p> <code>'::'</code> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the file does not exist.</p> Source code in <code>src/aiobsidian/resources/vault.py</code> <pre><code>async def patch(\n    self,\n    path: str,\n    content: str,\n    *,\n    operation: PatchOperation,\n    target_type: TargetType,\n    target: str,\n    target_delimiter: str = \"::\",\n) -&gt; None:\n    \"\"\"Patch a specific section of a vault file.\n\n    Args:\n        path: Path to the file relative to the vault root.\n        content: Content to insert or replace.\n        operation: How to apply the content (`append`, `prepend`,\n            or `replace`).\n        target_type: What to target (`heading`, `block`, or\n            `frontmatter`).\n        target: The target identifier (e.g. heading text, block ID,\n            or frontmatter field name).\n        target_delimiter: Delimiter for nested targets.\n\n    Raises:\n        NotFoundError: If the file does not exist.\n    \"\"\"\n    await self._patch_content(\n        f\"{self._BASE_URL}/{path}\",\n        content,\n        operation=operation,\n        target_type=target_type,\n        target=target,\n        target_delimiter=target_delimiter,\n    )\n</code></pre>"},{"location":"reference/resources/vault/#aiobsidian.resources.vault.VaultResource.delete","title":"<code>delete(path)</code>  <code>async</code>","text":"<p>Delete a file from the vault.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the file relative to the vault root.</p> required <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If the file does not exist.</p> Source code in <code>src/aiobsidian/resources/vault.py</code> <pre><code>async def delete(self, path: str) -&gt; None:\n    \"\"\"Delete a file from the vault.\n\n    Args:\n        path: Path to the file relative to the vault root.\n\n    Raises:\n        NotFoundError: If the file does not exist.\n    \"\"\"\n    await self._client.request(\"DELETE\", f\"{self._BASE_URL}/{path}\")\n</code></pre>"},{"location":"reference/resources/vault/#aiobsidian.resources.vault.VaultResource.list","title":"<code>list(path='')</code>  <code>async</code>","text":"<p>List files in a vault directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Directory path relative to the vault root. Empty string for the root directory.</p> <code>''</code> <p>Returns:</p> Type Description <code>VaultDirectory</code> <p>A <code>VaultDirectory</code> containing the list of file paths.</p> Source code in <code>src/aiobsidian/resources/vault.py</code> <pre><code>async def list(self, path: str = \"\") -&gt; VaultDirectory:\n    \"\"\"List files in a vault directory.\n\n    Args:\n        path: Directory path relative to the vault root.\n            Empty string for the root directory.\n\n    Returns:\n        A `VaultDirectory` containing the list of file paths.\n    \"\"\"\n    path = path.strip(\"/\")\n    trailing = f\"{path}/\" if path else \"\"\n    response = await self._client.request(\"GET\", f\"{self._BASE_URL}/{trailing}\")\n    return VaultDirectory.model_validate(response.json())\n</code></pre>"}]}